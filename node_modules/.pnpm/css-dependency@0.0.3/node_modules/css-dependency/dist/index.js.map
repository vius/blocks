{"version":3,"sources":["../src/utils/lines.ts","../src/utils/result.ts","../src/utils/strings.ts","../src/parser/index.ts"],"names":["index"],"mappings":"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","file":"index.js","sourcesContent":["/*\n\tjsrepo 1.36.0\n\tInstalled from github/ieedan/std\n\t2-17-2025\n*/\n\nimport os from 'node:os';\nimport { leftPadMin } from './pad';\n\n/** Regex used to split on new lines\n *\n * ```\n * /\\n|\\r\\n/g\n * ```\n */\nexport const NEW_LINE_REGEX = /\\n|\\r\\n/g;\n\n/** Splits str into an array of lines.\n *\n * @param str\n * @returns\n *\n * ## Usage\n *\n * ```ts\n * lines.split(\"hello\\\\nhello\\nhello\"); // [\"hello\\\\nhello\", \"hello\"]\n * ```\n */\nconst get = (str: string): string[] => str.split(NEW_LINE_REGEX);\n\nexport type Options = {\n\tlineNumbers: boolean;\n\tprefix: (line: number, lineCount: number) => string;\n};\n\n/** Joins the array of lines back into a string using the platform specific EOL.\n *\n * @param lines\n * @returns\n *\n * ## Usage\n *\n * ```ts\n * lines.join([\"1\", \"2\", \"3\"]); // \"1\\n2\\n3\" or on windows \"1\\r\\n2\\r\\n3\"\n *\n * // add line numbers\n * lines.join([\"import { } from '.'\", \"console.log('test')\"], { lineNumbers: true });\n * // 1 import {  } from '.'\n * // 2 console.log('test')\n *\n * // add a custom prefix\n * lines.join([\"import { } from '.'\", \"console.log('test')\"], { prefix: () => \" + \" });\n * // + import {  } from '.'\n * // + console.log('test')\n * ```\n */\nconst join = (lines: string[], { lineNumbers = false, prefix }: Partial<Options> = {}): string => {\n\tlet transformed = lines;\n\n\tif (lineNumbers) {\n\t\tconst length = lines.length.toString().length + 1;\n\n\t\ttransformed = transformed.map((line, i) => `${leftPadMin(`${i + 1}`, length)} ${line}`);\n\t}\n\n\tif (prefix !== undefined) {\n\t\ttransformed = transformed.map((line, i) => `${prefix(i, lines.length)}${line}`);\n\t}\n\n\treturn transformed.join(os.EOL);\n};\n\nexport { get, join };\n","/*\n\tjsrepo 1.36.0\n\tInstalled from github/ieedan/std\n\t2-17-2025\n*/\n\n/** This is just a helper type used only within this file */\ntype _Result<T, E> = { ok: true; val: T } | { ok: false; err: E };\n\n/** Result allows you to show to a consumer that a function might throw and force them to handle it.\n *\n *  `T` Value type\n *\n *  `E` Error type\n *\n * ## Usage\n *\n * ```ts\n * function functionThatMightFail(): Result<T, E>;\n * ```\n *\n * ## Examples\n *\n * ```ts\n * const functionThatMightFail = (): Result<string, string> => Ok(\"Hello, World!\");\n *\n * const result = functionThatMightFail();\n *\n * console.log(result.unwrap()); // \"Hello, World!\"\n * ```\n */\nclass Result<T, E> {\n\tprivate readonly _result: _Result<T, E>;\n\n\tconstructor(result: _Result<T, E>) {\n\t\tthis._result = result;\n\t}\n\n\t/** Allows you to run callbacks based on the result.\n\t *\n\t * @param success callback to be run when result is success\n\t * @param failure callback to be run when result is failure\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.match(\n\t * \t(val) => val,\n\t * \t() => {\n\t * \t\tthrow new Error('oops!')\n\t * \t}\n\t * );\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"Hello, World!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * const val = result.match(\n\t * \t(val) => val,\n\t * \t() => {\n\t * \t\tthrow new Error('oops!')\n\t * \t}\n\t * );\n\t *\n\t * console.log(val); // \"Hello, World!\"\n\t * ```\n\t */\n\tmatch<A, B = A>(success: (val: T) => A, failure: (err: E) => B): A | B {\n\t\tif (!this._result.ok) {\n\t\t\treturn failure(this._result.err);\n\t\t}\n\n\t\treturn success(this._result.val);\n\t}\n\n\t/** Maps `Result<T, E>` to `Result<A, E>` using the passed mapping function\n\t *\n\t * @param fn Mapping function\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.map((val) => val.length);\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"Hello, World!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * const hello = result.map((val) => val.slice(0, 5));\n\t *\n\t * console.log(hello.unwrap()); // \"Hello\"\n\t * ```\n\t */\n\tmap<A>(fn: (val: T) => A): Result<A, E> {\n\t\treturn this.match(\n\t\t\t(val) => Ok(fn(val)),\n\t\t\t(err) => Err(err)\n\t\t);\n\t}\n\n\t/** In the `Ok` case returns the mapped value using the function else returns `defaultVal`\n\t *\n\t * @param defaultVal Value to be returned when `Err`\n\t * @param fn Mapping function to map in case of `Ok`\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.mapOr(1, (val) => val.length);\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ### When `Ok`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"foo\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * const length = result.mapOr(1, (val) => val.length);\n\t *\n\t * console.log(length); // 3\n\t * ```\n\t *\n\t * ### When `Err`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(\"oops!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * const length = result.mapOr(1, (val) => val.length);\n\t *\n\t * console.log(length); // 1\n\t * ```\n\t */\n\tmapOr<A>(defaultVal: A, fn: (val: T) => A): A {\n\t\treturn this.match(\n\t\t\t(val) => fn(val),\n\t\t\t(_) => defaultVal\n\t\t);\n\t}\n\n\t/** In the `Ok` case returns the mapped value using `fn` else returns value of `def`\n\t *\n\t * @param def Mapping function called when `Err`\n\t * @param fn Mapping function called when `Ok`\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.mapOrElse(() => 1, (val) => val.length);\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ### When `Ok`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"foo\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * const length = result.mapOrElse(() => 1, (val) => val.length);\n\t *\n\t * console.log(length); // 3\n\t * ```\n\t *\n\t * ### When `Err`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(\"oops!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * const length = result.mapOr(() => 1, (val) => val.length);\n\t *\n\t * console.log(length); // 1\n\t * ```\n\t */\n\tmapOrElse<A>(def: (err: E) => A, fn: (val: T) => A): A {\n\t\treturn this.match(\n\t\t\t(val) => fn(val),\n\t\t\t(err) => def(err)\n\t\t);\n\t}\n\n\t/** Maps `Result<T, E>` to `Result<T, A>` using the passed mapping function\n\t *\n\t * @param fn Mapping function\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.mapErr((err) => getCodeMsg(err));\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(10);\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * const message = result.mapErr(() => \"Error\");\n\t *\n\t * console.log(message); // \"Error\"\n\t * ```\n\t */\n\tmapErr<A>(fn: (err: E) => A): Result<T, A> {\n\t\treturn this.match(\n\t\t\t(val) => Ok(val),\n\t\t\t(err) => Err(fn(err))\n\t\t);\n\t}\n\n\t/** In the `Err` case returns the mapped value using the function else returns `defaultVal`\n\t *\n\t * @param defaultVal Value to be returned when `Ok`\n\t * @param fn Mapping function to map in case of `Err`\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.mapErrOr(\"Should've been error\", (err) => getCodeMsg(err));\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ### When `Ok`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"foo\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * const message = result.mapErrOr(\"Should've been error\", () => \"Error\");\n\t *\n\t * console.log(message); // \"Should've been error\"\n\t * ```\n\t *\n\t * ### When `Err`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(10);\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * const message = result.mapErrOr(\"Should've been error\", () => \"Error\");\n\t *\n\t * console.log(message); // \"Error\"\n\t * ```\n\t */\n\tmapErrOr<A>(defaultVal: A, fn: (err: E) => A): A {\n\t\treturn this.match(\n\t\t\t(_) => defaultVal,\n\t\t\t(err) => fn(err)\n\t\t);\n\t}\n\n\t/** In the `Err` case returns the mapped value using the function else returns value of `def`\n\t *\n\t * @param def Mapping function called when `Ok`\n\t * @param fn Mapping function called when `Err`\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.mapErrOrElse(() => \"Value\", (_) => \"Error!\");\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ### When `Ok`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"foo\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * const length = result.mapErrOrElse(() => 1, (val) => val.length);\n\t *\n\t * console.log(length); // 1\n\t * ```\n\t *\n\t * ### When `Err`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(\"oops!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * const length = result.mapOr(() => 1, (val) => val.length);\n\t *\n\t * console.log(length); // 4\n\t * ```\n\t */\n\tmapErrOrElse<A>(def: (val: T) => A, fn: (err: E) => A): A {\n\t\treturn this.match(\n\t\t\t(val) => def(val),\n\t\t\t(err) => fn(err)\n\t\t);\n\t}\n\n\t/** Returns true if result is `Ok`\n\t *\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.isOk();\n\t * ```\n\t */\n\tisOk(): boolean {\n\t\treturn this.match(\n\t\t\t() => true,\n\t\t\t() => false\n\t\t);\n\t}\n\n\t/** Returns true if result is `Err`\n\t *\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.isErr();\n\t * ```\n\t */\n\tisErr(): boolean {\n\t\treturn this.match(\n\t\t\t() => false,\n\t\t\t() => true\n\t\t);\n\t}\n\n\t/** Tries to return value if value is `Err` throws generic error message.\n\t *\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.unwrap();\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ### When `Ok`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"Hello!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.unwrap()); // \"Hello!\"\n\t * ```\n\t *\n\t * ### When `Err`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(\"oops!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * result.unwrap(); // Error: Attempted to call `.unwrap()` on a non `Ok` value.\n\t * ```\n\t */\n\tunwrap(): T {\n\t\treturn this.match(\n\t\t\t(val) => val,\n\t\t\t() => {\n\t\t\t\tthrow new Error('Attempted to call `.unwrap()` on a non `Ok` value.');\n\t\t\t}\n\t\t);\n\t}\n\n\t/** Tries to return err if value is `Ok` throws generic error message.\n\t *\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.unwrapErr();\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ### When `Ok`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"Hello!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * result.unwrapErr(); // Error: Attempted to call `.unwrapErr()` on a non `Err` value.\n\t * ```\n\t *\n\t * ### When `Err`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(\"oops!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.unwrapErr()); // \"oops!\"\n\t * ```\n\t */\n\tunwrapErr(): E {\n\t\treturn this.match(\n\t\t\t() => {\n\t\t\t\tthrow new Error('Attempted to call `.unwrapErr()` on a non `Err` value.');\n\t\t\t},\n\t\t\t(err) => err\n\t\t);\n\t}\n\n\t/** Tries to unwrap the value if value is `Err` returns `defaultVal`\n\t *\n\t * @param defaultVal Value to be returned if `Err`\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.unwrapOr(7);\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ### When `Ok`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"Hello!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.unwrapOr(\"Yellow!\")); // \"Hello!\"\n\t * ```\n\t *\n\t * ### When `Err`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(\"oops!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.unwrapOr(\"Yellow!\")); // \"Yellow!\"\n\t * ```\n\t */\n\tunwrapOr(defaultVal: T): T {\n\t\treturn this.match(\n\t\t\t(val) => val,\n\t\t\t(_) => defaultVal\n\t\t);\n\t}\n\n\t/** Tries to unwrap the error if vale is `Ok` returns `defaultVal`\n\t *\n\t * @param defaultVal\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.unwrapErrOr(\"Error\");\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ### When `Ok`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"Hello!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.unwrapErrOr(\"Yellow!\")); // \"Yellow!\"\n\t * ```\n\t *\n\t * ### When `Err`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(\"oops!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.unwrapErrOr(\"Yellow!\")); // \"oops!\"\n\t * ```\n\t */\n\tunwrapErrOr(defaultVal: E): E {\n\t\treturn this.match(\n\t\t\t() => defaultVal,\n\t\t\t(err) => err\n\t\t);\n\t}\n\n\t/** Tries to return the value if value is `Err` calls `fn`\n\t *\n\t * @param fn Function called if `Err`\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.unwrapOrElse(() => \"Hello!\");\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ### When `Ok`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"Hello!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.unwrapOrElse(() => \"oops!\")); // \"Hello!\"\n\t * ```\n\t *\n\t * ### When `Err`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(\"oops!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.unwrapOrElse(() => \"Hello!\")); // \"Hello!\"\n\t * ```\n\t *\n\t */\n\tunwrapOrElse(fn: (err: E) => T): T {\n\t\treturn this.match(\n\t\t\t(val) => val,\n\t\t\t(err) => fn(err)\n\t\t);\n\t}\n\n\t/** Tries to return the error if value is `Ok` calls `fn`\n\t *\n\t * @param fn Function called if `Ok`\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.unwrapErrOrElse(() => \"Error!\");\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ### When `Ok`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"Hello!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.unwrapErrOrElse(() => \"oops!\")); // \"oops!\"\n\t * ```\n\t *\n\t * ### When `Err`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(\"oops!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.unwrapErrOrElse(() => \"Hello!\")); // \"oops!\"\n\t * ```\n\t *\n\t */\n\tunwrapErrOrElse(fn: (val: T) => E): E {\n\t\treturn this.match(\n\t\t\t(val) => fn(val),\n\t\t\t(err) => err\n\t\t);\n\t}\n\n\t/** Tries to return value if value is `Err` throws custom error message.\n\t *\n\t * @param message Message to show when value is `Err`\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.expect(\"Custom message\");\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ### When `Ok`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"Hello!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.expect(\"I failed!\")); // \"Hello!\"\n\t * ```\n\t *\n\t * ### When `Err`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(\"oops!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * result.expect(\"I failed!\"); // Error: I failed!\n\t * ```\n\t */\n\texpect(message: string): T {\n\t\treturn this.match(\n\t\t\t(val) => val,\n\t\t\t() => {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t);\n\t}\n\n\t/** Tries to return error value if value is `Ok` throws custom error message\n\t *\n\t * @param message\n\t * @returns\n\t *\n\t * ## Usage\n\t *\n\t * ```ts\n\t * result.expectErr(\"Custom message\");\n\t * ```\n\t *\n\t * ## Examples\n\t *\n\t * ### When `Ok`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Ok(\"Hello!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.expectErr(\"I failed!\")); // Error: I failed!\n\t * ```\n\t *\n\t * ### When `Err`\n\t *\n\t * ```ts\n\t * const functionThatMightFail = (): Result<string, string> => Err(\"oops!\");\n\t *\n\t * const result = functionThatMightFail();\n\t *\n\t * console.log(result.expectErr(\"I failed!\")); // \"oops!\"\n\t * ```\n\t */\n\texpectErr(message: string): E {\n\t\treturn this.match(\n\t\t\t() => {\n\t\t\t\tthrow new Error(message);\n\t\t\t},\n\t\t\t(err) => err\n\t\t);\n\t}\n}\n\n/** Returns a new `Ok` result type with the provided value\n *\n * @param val Value of the result\n * @returns\n *\n * ## Usage\n *\n * ```ts\n * Ok(true);\n * ```\n *\n * ## Examples\n *\n * ```ts\n * const functionThatCanFail = (condition) => {\n * \tif (condition) {\n * \t\tOk(\"Success\")\n * \t}\n *\n * \treturn Err(\"Failure\");\n * }\n * ```\n */\nconst Ok = <T>(val: T): Result<T, never> => {\n\treturn new Result<T, never>({ ok: true, val });\n};\n\n/** Returns a new `Err` result type with the provided error\n *\n * @param err Error of the result\n * @returns\n *\n * ## Usage\n *\n * ```ts\n * Err(\"I failed!\");\n * ```\n *\n * ## Examples\n *\n * ```ts\n * const functionThatCanFail = (condition) => {\n * \tif (condition) {\n * \t\tOk(\"Success\")\n * \t}\n *\n * \treturn Err(\"Failure\");\n * }\n * ```\n */\nconst Err = <E>(err: E): Result<never, E> => {\n\treturn new Result<never, E>({ ok: false, err });\n};\n\nexport { type Result, Ok, Err };\n","/** Returns true if `str` starts with one of the provided `strings`.\n *\n * ## Usage\n * ```ts\n * startsWithOneOf('ab', 'a', 'c'); // true\n * startsWithOneOf('cc', 'a', 'b'); // false\n * ```\n *\n * @param str\n * @param strings\n * @returns\n */\nexport const startsWithOneOf = (str: string, strings: string[]): boolean => {\n\tfor (const s of strings) {\n\t\tif (str.startsWith(s)) return true;\n\t}\n\n\treturn false;\n};\n\n/** Returns true if `str` starts with one of the provided `strings`.\n *\n * ## Usage\n * ```ts\n * endsWithOneOf('cb', 'a', 'b'); // true\n * endsWithOneOf('cc', 'a', 'b'); // false\n * ```\n *\n * @param str\n * @param strings\n * @returns\n */\nexport const endsWithOneOf = (str: string, strings: string[]): boolean => {\n\tfor (const s of strings) {\n\t\tif (str.endsWith(s)) return true;\n\t}\n\n\treturn false;\n};\n","import * as l from '../utils/lines';\nimport { Err, Ok, type Result } from '../utils/result';\nimport * as s from '../utils/strings';\n\nexport type Import = {\n\t/** The @ directive used for the import */\n\tdirective: string;\n\t/** The module that was imported */\n\tmodule: string;\n\t/** The code responsible for the import */\n\traw: string;\n};\n\nexport type Options = {\n\t/** Enable this to allow tailwind directives `@plugin`, `@config`, `@reference`\n\t *\n\t * @default false\n\t */\n\tallowTailwindDirectives: boolean;\n\t/** Enable to skip over errors and just return the valid imports.\n\t *\n\t * @default false\n\t */\n\tignoreErrors: boolean;\n};\n\nexport type ParseError = {\n\tmessage: string;\n\tline: number;\n};\n\nconst TAILWIND_DIRECTIVES = ['@plugin', '@config', '@reference'];\n\n/** Parses the css and returns any imports.\n *\n * @param code the code to be parsed\n * @param options parsing options\n * @returns\n *\n * ## Usage\n * ```ts\n * const code = '@import \"./util.css\";';\n *\n * const imports = parse(code);\n *\n * assert.deepStrictEqual(\n *      imports.unwrap(),\n *      [\n *          {\n *              directive: \"@import\",\n *              module: \"./util.css\",\n *              raw: '@import \"./util.css\";'\n *          }\n *      ]\n * );\n * ```\n */\nexport const parse = (\n\tcode: string,\n\t{ allowTailwindDirectives = false, ignoreErrors = false }: Partial<Options> = {}\n): Result<Import[], ParseError> => {\n\tconst imports: Import[] = [];\n\n\tconst directives = ['@import'];\n\n\tif (allowTailwindDirectives) {\n\t\tdirectives.push(...TAILWIND_DIRECTIVES);\n\t}\n\n\tconst lines = l.get(code);\n\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tconst line = lines[i].trim();\n\n\t\tif (\n\t\t\ts.startsWithOneOf(\n\t\t\t\tline,\n\t\t\t\tdirectives.map((d) => `${d} `)\n\t\t\t)\n\t\t) {\n\t\t\tconst [directive, moduleExpr] = line.split(' ');\n\n\t\t\tconst parsed = parseModule(moduleExpr);\n\n\t\t\tif (parsed === null) {\n\t\t\t\tif (ignoreErrors) continue;\n\n\t\t\t\treturn Err({\n\t\t\t\t\tline: i + 1,\n\t\t\t\t\tmessage: `Encountered a syntax error while parsing the import expression on line ${i + 1}.`,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst imp: Import = {\n\t\t\t\traw: line,\n\t\t\t\tdirective,\n\t\t\t\tmodule: parsed,\n\t\t\t};\n\n\t\t\timports.push(imp);\n\t\t}\n\t}\n\n\treturn Ok(imports);\n};\n\nconst parseModule = (moduleExpr: string): string | null => {\n\tif (moduleExpr.startsWith('url(')) {\n\t\tconst index = moduleExpr.lastIndexOf(')');\n\n\t\tif (index === -1) return null;\n\n\t\treturn moduleExpr.slice(5, index - 1);\n\t}\n\n\tconst quoteType = moduleExpr[0];\n\n\tconst index = moduleExpr.indexOf(quoteType, 2);\n\n\tif (index === -1) return null;\n\n\t// trims the quotes\n\treturn moduleExpr.slice(1, index);\n};\n"]}