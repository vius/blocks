import 'ansi-regex';

// src/utils/strip-ansi.ts

// src/utils/lines.ts
var NEW_LINE_REGEX = /\n|\r\n/g;
var get = (str) => str.split(NEW_LINE_REGEX);

// src/utils/result.ts
var Result = class {
  _result;
  constructor(result) {
    this._result = result;
  }
  /** Allows you to run callbacks based on the result.
   *
   * @param success callback to be run when result is success
   * @param failure callback to be run when result is failure
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.match(
   * 	(val) => val,
   * 	() => {
   * 		throw new Error('oops!')
   * 	}
   * );
   * ```
   *
   * ## Examples
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("Hello, World!");
   *
   * const result = functionThatMightFail();
   *
   * const val = result.match(
   * 	(val) => val,
   * 	() => {
   * 		throw new Error('oops!')
   * 	}
   * );
   *
   * console.log(val); // "Hello, World!"
   * ```
   */
  match(success, failure) {
    if (!this._result.ok) {
      return failure(this._result.err);
    }
    return success(this._result.val);
  }
  /** Maps `Result<T, E>` to `Result<A, E>` using the passed mapping function
   *
   * @param fn Mapping function
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.map((val) => val.length);
   * ```
   *
   * ## Examples
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("Hello, World!");
   *
   * const result = functionThatMightFail();
   *
   * const hello = result.map((val) => val.slice(0, 5));
   *
   * console.log(hello.unwrap()); // "Hello"
   * ```
   */
  map(fn) {
    return this.match(
      (val) => Ok(fn(val)),
      (err) => Err(err)
    );
  }
  /** In the `Ok` case returns the mapped value using the function else returns `defaultVal`
   *
   * @param defaultVal Value to be returned when `Err`
   * @param fn Mapping function to map in case of `Ok`
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.mapOr(1, (val) => val.length);
   * ```
   *
   * ## Examples
   *
   * ### When `Ok`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("foo");
   *
   * const result = functionThatMightFail();
   *
   * const length = result.mapOr(1, (val) => val.length);
   *
   * console.log(length); // 3
   * ```
   *
   * ### When `Err`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err("oops!");
   *
   * const result = functionThatMightFail();
   *
   * const length = result.mapOr(1, (val) => val.length);
   *
   * console.log(length); // 1
   * ```
   */
  mapOr(defaultVal, fn) {
    return this.match(
      (val) => fn(val),
      (_) => defaultVal
    );
  }
  /** In the `Ok` case returns the mapped value using `fn` else returns value of `def`
   *
   * @param def Mapping function called when `Err`
   * @param fn Mapping function called when `Ok`
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.mapOrElse(() => 1, (val) => val.length);
   * ```
   *
   * ## Examples
   *
   * ### When `Ok`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("foo");
   *
   * const result = functionThatMightFail();
   *
   * const length = result.mapOrElse(() => 1, (val) => val.length);
   *
   * console.log(length); // 3
   * ```
   *
   * ### When `Err`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err("oops!");
   *
   * const result = functionThatMightFail();
   *
   * const length = result.mapOr(() => 1, (val) => val.length);
   *
   * console.log(length); // 1
   * ```
   */
  mapOrElse(def, fn) {
    return this.match(
      (val) => fn(val),
      (err) => def(err)
    );
  }
  /** Maps `Result<T, E>` to `Result<T, A>` using the passed mapping function
   *
   * @param fn Mapping function
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.mapErr((err) => getCodeMsg(err));
   * ```
   *
   * ## Examples
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err(10);
   *
   * const result = functionThatMightFail();
   *
   * const message = result.mapErr(() => "Error");
   *
   * console.log(message); // "Error"
   * ```
   */
  mapErr(fn) {
    return this.match(
      (val) => Ok(val),
      (err) => Err(fn(err))
    );
  }
  /** In the `Err` case returns the mapped value using the function else returns `defaultVal`
   *
   * @param defaultVal Value to be returned when `Ok`
   * @param fn Mapping function to map in case of `Err`
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.mapErrOr("Should've been error", (err) => getCodeMsg(err));
   * ```
   *
   * ## Examples
   *
   * ### When `Ok`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("foo");
   *
   * const result = functionThatMightFail();
   *
   * const message = result.mapErrOr("Should've been error", () => "Error");
   *
   * console.log(message); // "Should've been error"
   * ```
   *
   * ### When `Err`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err(10);
   *
   * const result = functionThatMightFail();
   *
   * const message = result.mapErrOr("Should've been error", () => "Error");
   *
   * console.log(message); // "Error"
   * ```
   */
  mapErrOr(defaultVal, fn) {
    return this.match(
      (_) => defaultVal,
      (err) => fn(err)
    );
  }
  /** In the `Err` case returns the mapped value using the function else returns value of `def`
   *
   * @param def Mapping function called when `Ok`
   * @param fn Mapping function called when `Err`
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.mapErrOrElse(() => "Value", (_) => "Error!");
   * ```
   *
   * ## Examples
   *
   * ### When `Ok`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("foo");
   *
   * const result = functionThatMightFail();
   *
   * const length = result.mapErrOrElse(() => 1, (val) => val.length);
   *
   * console.log(length); // 1
   * ```
   *
   * ### When `Err`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err("oops!");
   *
   * const result = functionThatMightFail();
   *
   * const length = result.mapOr(() => 1, (val) => val.length);
   *
   * console.log(length); // 4
   * ```
   */
  mapErrOrElse(def, fn) {
    return this.match(
      (val) => def(val),
      (err) => fn(err)
    );
  }
  /** Returns true if result is `Ok`
   *
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.isOk();
   * ```
   */
  isOk() {
    return this.match(
      () => true,
      () => false
    );
  }
  /** Returns true if result is `Err`
   *
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.isErr();
   * ```
   */
  isErr() {
    return this.match(
      () => false,
      () => true
    );
  }
  /** Tries to return value if value is `Err` throws generic error message.
   *
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.unwrap();
   * ```
   *
   * ## Examples
   *
   * ### When `Ok`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("Hello!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.unwrap()); // "Hello!"
   * ```
   *
   * ### When `Err`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err("oops!");
   *
   * const result = functionThatMightFail();
   *
   * result.unwrap(); // Error: Attempted to call `.unwrap()` on a non `Ok` value.
   * ```
   */
  unwrap() {
    return this.match(
      (val) => val,
      () => {
        throw new Error("Attempted to call `.unwrap()` on a non `Ok` value.");
      }
    );
  }
  /** Tries to return err if value is `Ok` throws generic error message.
   *
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.unwrapErr();
   * ```
   *
   * ## Examples
   *
   * ### When `Ok`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("Hello!");
   *
   * const result = functionThatMightFail();
   *
   * result.unwrapErr(); // Error: Attempted to call `.unwrapErr()` on a non `Err` value.
   * ```
   *
   * ### When `Err`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err("oops!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.unwrapErr()); // "oops!"
   * ```
   */
  unwrapErr() {
    return this.match(
      () => {
        throw new Error("Attempted to call `.unwrapErr()` on a non `Err` value.");
      },
      (err) => err
    );
  }
  /** Tries to unwrap the value if value is `Err` returns `defaultVal`
   *
   * @param defaultVal Value to be returned if `Err`
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.unwrapOr(7);
   * ```
   *
   * ## Examples
   *
   * ### When `Ok`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("Hello!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.unwrapOr("Yellow!")); // "Hello!"
   * ```
   *
   * ### When `Err`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err("oops!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.unwrapOr("Yellow!")); // "Yellow!"
   * ```
   */
  unwrapOr(defaultVal) {
    return this.match(
      (val) => val,
      (_) => defaultVal
    );
  }
  /** Tries to unwrap the error if vale is `Ok` returns `defaultVal`
   *
   * @param defaultVal
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.unwrapErrOr("Error");
   * ```
   *
   * ## Examples
   *
   * ### When `Ok`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("Hello!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.unwrapErrOr("Yellow!")); // "Yellow!"
   * ```
   *
   * ### When `Err`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err("oops!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.unwrapErrOr("Yellow!")); // "oops!"
   * ```
   */
  unwrapErrOr(defaultVal) {
    return this.match(
      () => defaultVal,
      (err) => err
    );
  }
  /** Tries to return the value if value is `Err` calls `fn`
   *
   * @param fn Function called if `Err`
   *
   * ## Usage
   *
   * ```ts
   * result.unwrapOrElse(() => "Hello!");
   * ```
   *
   * ## Examples
   *
   * ### When `Ok`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("Hello!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.unwrapOrElse(() => "oops!")); // "Hello!"
   * ```
   *
   * ### When `Err`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err("oops!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.unwrapOrElse(() => "Hello!")); // "Hello!"
   * ```
   *
   */
  unwrapOrElse(fn) {
    return this.match(
      (val) => val,
      (err) => fn(err)
    );
  }
  /** Tries to return the error if value is `Ok` calls `fn`
   *
   * @param fn Function called if `Ok`
   *
   * ## Usage
   *
   * ```ts
   * result.unwrapErrOrElse(() => "Error!");
   * ```
   *
   * ## Examples
   *
   * ### When `Ok`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("Hello!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.unwrapErrOrElse(() => "oops!")); // "oops!"
   * ```
   *
   * ### When `Err`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err("oops!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.unwrapErrOrElse(() => "Hello!")); // "oops!"
   * ```
   *
   */
  unwrapErrOrElse(fn) {
    return this.match(
      (val) => fn(val),
      (err) => err
    );
  }
  /** Tries to return value if value is `Err` throws custom error message.
   *
   * @param message Message to show when value is `Err`
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.expect("Custom message");
   * ```
   *
   * ## Examples
   *
   * ### When `Ok`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("Hello!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.expect("I failed!")); // "Hello!"
   * ```
   *
   * ### When `Err`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err("oops!");
   *
   * const result = functionThatMightFail();
   *
   * result.expect("I failed!"); // Error: I failed!
   * ```
   */
  expect(message) {
    return this.match(
      (val) => val,
      () => {
        throw new Error(message);
      }
    );
  }
  /** Tries to return error value if value is `Ok` throws custom error message
   *
   * @param message
   * @returns
   *
   * ## Usage
   *
   * ```ts
   * result.expectErr("Custom message");
   * ```
   *
   * ## Examples
   *
   * ### When `Ok`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Ok("Hello!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.expectErr("I failed!")); // Error: I failed!
   * ```
   *
   * ### When `Err`
   *
   * ```ts
   * const functionThatMightFail = (): Result<string, string> => Err("oops!");
   *
   * const result = functionThatMightFail();
   *
   * console.log(result.expectErr("I failed!")); // "oops!"
   * ```
   */
  expectErr(message) {
    return this.match(
      () => {
        throw new Error(message);
      },
      (err) => err
    );
  }
};
var Ok = (val) => {
  return new Result({ ok: true, val });
};
var Err = (err) => {
  return new Result({ ok: false, err });
};

// src/utils/strings.ts
var startsWithOneOf = (str, strings) => {
  for (const s of strings) {
    if (str.startsWith(s)) return true;
  }
  return false;
};

// src/parser/index.ts
var TAILWIND_DIRECTIVES = ["@plugin", "@config", "@reference"];
var parse = (code, { allowTailwindDirectives = false, ignoreErrors = false } = {}) => {
  const imports = [];
  const directives = ["@import"];
  if (allowTailwindDirectives) {
    directives.push(...TAILWIND_DIRECTIVES);
  }
  const lines = get(code);
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (startsWithOneOf(
      line,
      directives.map((d) => `${d} `)
    )) {
      const [directive, moduleExpr] = line.split(" ");
      const parsed = parseModule(moduleExpr);
      if (parsed === null) {
        if (ignoreErrors) continue;
        return Err({
          line: i + 1,
          message: `Encountered a syntax error while parsing the import expression on line ${i + 1}.`
        });
      }
      const imp = {
        raw: line,
        directive,
        module: parsed
      };
      imports.push(imp);
    }
  }
  return Ok(imports);
};
var parseModule = (moduleExpr) => {
  if (moduleExpr.startsWith("url(")) {
    const index2 = moduleExpr.lastIndexOf(")");
    if (index2 === -1) return null;
    return moduleExpr.slice(5, index2 - 1);
  }
  const quoteType = moduleExpr[0];
  const index = moduleExpr.indexOf(quoteType, 2);
  if (index === -1) return null;
  return moduleExpr.slice(1, index);
};

export { parse };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map