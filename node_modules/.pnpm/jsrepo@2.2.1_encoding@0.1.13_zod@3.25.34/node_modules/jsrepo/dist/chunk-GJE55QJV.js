import*as o from'valibot';import y from'chalk';var Q=o.object({name:o.string(),category:o.string(),localDependencies:o.array(o.string()),dependencies:o.array(o.string()),devDependencies:o.array(o.string()),tests:o.boolean(),list:o.optional(o.boolean(),true),directory:o.string(),subdirectory:o.boolean(),files:o.array(o.string()),_imports_:o.record(o.string(),o.string())}),T=o.object({name:o.string(),blocks:o.array(Q)}),J=o.object({authors:o.optional(o.array(o.string())),bugs:o.optional(o.string()),description:o.optional(o.string()),homepage:o.optional(o.string()),repository:o.optional(o.string()),tags:o.optional(o.array(o.string()))}),q=o.record(o.string(),o.union([o.string(),o.object({version:o.string(),message:o.string()})])),K=o.object({name:o.string(),path:o.string(),expectedPath:o.optional(o.string()),optional:o.optional(o.boolean(),false)}),V=o.object({...K.entries,dependencies:o.optional(o.array(o.string())),devDependencies:o.optional(o.array(o.string()))}),X=o.union([o.literal("public"),o.literal("private"),o.literal("marketplace")]),F=o.object({name:o.optional(o.string()),version:o.optional(o.string()),meta:o.optional(J),access:o.optional(X),peerDependencies:o.optional(q),configFiles:o.optional(o.array(V)),categories:o.array(T)});var _="jsrepo-manifest.json",ae="jsrepo.json";var Z="main",b={name:"azure",matches:r=>r.toLowerCase().startsWith("azure"),parse:(r,e)=>{let t=O(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{owner:e,repoName:t}=O(r,{fullyQualified:false});return `https://dev.azure.com/${e}/_git/${t}`},state:async r=>{let{url:e,owner:t,project:i,repoName:a,ref:n,refs:s}=O(r,{fullyQualified:false});return {owner:t,repoName:a,ref:n,refs:s,project:i,url:e,provider:b}},resolveRaw:async(r,e)=>{if(r.provider.name!==b.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${b.name} provider.`);let{owner:t,repoName:i,project:a,ref:n,refs:s}=r,p=s==="tags"?"tag":"branch";return new URL(`https://dev.azure.com/${t}/${a}/_apis/git/repositories/${i}/items?path=${e}&api-version=7.2-preview.1&versionDescriptor.version=${n}&versionDescriptor.versionType=${p}`)},authHeader:r=>["Authorization",`Bearer ${r}`],formatFetchError:(r,e)=>`There was an error fetching \`${y.bold(e)}\` from ${y.bold(r.url)}.

${y.bold("This may be for one of the following reasons:")}
1. Either \`${y.bold(e)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
4. The cached state for this git provider is incorrect (try using ${y.bold("--no-cache")})
`};function O(r,{fullyQualified:e}){let t=r.replaceAll(/(azure\/)/g,""),[i,a,n,...s]=t.split("/"),p;e&&(p=s.slice(s.length-2).join("/"),s=s.slice(0,s.length-2));let c=Z,l="heads";return ["tags","heads"].includes(s[0])&&(l=s[0],s[1]&&s[1]!==""&&(c=s[1])),{url:`azure/${i}/${a}/${n}${c?`/${l}/${c}`:""}`,owner:i,repoName:n,project:a,ref:c,refs:l,specifier:p}}function h(r,e){for(let t of e)if(r.startsWith(t))return  true;return  false}function ue(r,e){for(let t of e)if(r.endsWith(t))return  true;return  false}var z="master",m={name:"bitbucket",matches:r=>h(r.toLowerCase(),["bitbucket","https://bitbucket.org"]),parse:(r,e)=>{let t=j(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{owner:e,repoName:t}=j(r,{fullyQualified:false});return `https://bitbucket.org/${e}/${t}`},state:async(r,{token:e,fetch:t=fetch}={})=>{let{url:i,owner:a,repoName:n,ref:s}=j(r,{fullyQualified:false});if(s===void 0)try{let p=new Headers;if(e!==void 0){let[l,d]=m.authHeader(e);p.append(l,d);}let c=await t(`https://api.bitbucket.org/2.0/repositories/${a}/${n}`,{headers:p});c.ok?s=(await c.json()).mainbranch.name:s=z;}catch{s=z;}return {owner:a,ref:s,repoName:n,url:i,provider:m}},resolveRaw:async(r,e)=>{if(r.provider.name!==m.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${m.name} provider.`);let{owner:t,repoName:i,ref:a}=r;return new URL(e,`https://api.bitbucket.org/2.0/repositories/${t}/${i}/src/${a}/`)},authHeader:r=>["Authorization",`Bearer ${r}`],formatFetchError:(r,e)=>`There was an error fetching \`${y.bold(e)}\` from ${y.bold(r.url)}.

${y.bold("This may be for one of the following reasons:")}
1. Either \`${y.bold(e)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
4. The cached state for this git provider is incorrect (try using ${y.bold("--no-cache")})
`};function j(r,{fullyQualified:e=false}){let t=r.replaceAll(/(https:\/\/bitbucket.org\/)|(bitbucket\/)/g,""),[i,a,...n]=t.split("/"),s;e&&(s=n.slice(n.length-2).join("/"),n=n.slice(0,n.length-2));let p;return n[0]==="src"&&(p=n[1]),{url:`bitbucket/${i}/${a}${p?`/src/${p}`:""}`,specifier:s,owner:i,repoName:a,ref:p}}var B="main",E={name:"github",matches:r=>h(r.toLowerCase(),["github","https://github.com"]),parse:(r,e)=>{let t=k(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{owner:e,repoName:t}=k(r,{fullyQualified:false});return `https://github.com/${e}/${t}`},state:async(r,{token:e}={})=>{let{url:t,owner:i,repoName:a,ref:n}=k(r,{fullyQualified:false});if(n===void 0)try{let s=await fetch(`https://api.github.com/repos/${i}/${a}`,{headers:{Authorization:`Bearer ${e}`}});s.ok?n=(await s.json()).default_branch:n=B;}catch{n=B;}return {owner:i,ref:n,repoName:a,url:t,provider:E}},resolveRaw:async(r,e)=>{if(r.provider.name!==E.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${E.name} provider.`);let{owner:t,repoName:i,ref:a}=r;return new URL(e,`https://ungh.cc/repos/${t}/${i}/files/${a}/`)},authHeader:r=>["Authorization",`token ${r}`],formatFetchError:(r,e)=>`There was an error fetching \`${y.bold(e)}\` from ${y.bold(r.url)}.

${y.bold("This may be for one of the following reasons:")}
1. Either \`${y.bold(e)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
4. The cached state for this git provider is incorrect (try using ${y.bold("--no-cache")})
`};function k(r,{fullyQualified:e=false}){let t=r.replaceAll(/(https:\/\/github.com\/)|(github\/)/g,""),[i,a,...n]=t.split("/"),s;e&&(s=n.slice(n.length-2).join("/"),n=n.slice(0,n.length-2));let p;return n.length>0&&n[0]==="tree"&&(p=n[1]),{url:`github/${i}/${a}${p?`/tree/${p}`:""}`,specifier:s,owner:i,repoName:a,ref:p}}function f(...r){return r.map(e=>ee(e)).filter(Boolean).join("/")}function ee(r){let e=re(r);return te(e)}function re(r){let e=r;return e.startsWith("/")&&(e=e.slice(1)),e}function te(r){let e=r;return e.endsWith("/")&&(e=e.slice(0,e.length-1)),e}function C(r){let e=r;return e.endsWith("/")||(e=`${e}/`),e}var I="main",M="https://gitlab.com",v={name:"gitlab",matches:r=>h(r.toLowerCase(),["gitlab/","gitlab:","https://gitlab.com"]),parse:(r,e)=>{let t=U(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{baseUrl:e,owner:t,repoName:i}=U(r,{fullyQualified:false});return f(e,t,i)},state:async(r,{token:e,fetch:t=fetch}={})=>{let{baseUrl:i,url:a,owner:n,repoName:s,ref:p}=U(r,{fullyQualified:false});if(p===void 0)try{let c=new Headers;if(e!==void 0){let[d,G]=v.authHeader(e);c.append(d,G);}let l=await t(f(i,`api/v4/projects/${encodeURIComponent(`${n}/${s}`)}`),{headers:c});l.ok?p=(await l.json()).default_branch:p=I;}catch{p=I;}return {owner:n,repoName:s,ref:p,baseUrl:i,url:a,provider:v}},resolveRaw:async(r,e)=>{if(r.provider.name!==v.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${v.name} provider.`);let{baseUrl:t,owner:i,repoName:a,ref:n}=r;return new URL(f(t,`api/v4/projects/${encodeURIComponent(`${i}/${a}`)}`,`repository/files/${encodeURIComponent(e)}/raw?ref=${n}`))},authHeader:r=>["PRIVATE-TOKEN",r],formatFetchError:(r,e,t)=>`There was an error fetching \`${y.bold(e)}\` from ${y.bold(r.url)}: ${t}.

${y.bold("This may be for one of the following reasons:")}
1. Either \`${y.bold(e)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
4. The cached state for this git provider is incorrect (try using ${y.bold("--no-cache")})
`};function U(r,{fullyQualified:e}){let t=M;r.startsWith("gitlab:")&&(t=new URL(r.slice(7)).origin);let i=r.replaceAll(/gitlab\/|https:\/\/gitlab\.com\/|gitlab:https?:\/\/[^/]+\//g,""),[a,n,...s]=i.split("/"),p;e&&(p=s.slice(s.length-2).join("/"),s=s.slice(0,s.length-2));let c;if(s[0]==="-"&&s[1]==="tree")if(s[2].includes("?")){let[d]=s[2].split("?");c=d;}else c=s[2];return {url:f(t!==M?`gitlab:${t}`:t,`${a}/${n}${c?`/-/tree/${c}`:""}`),baseUrl:t,owner:a,repoName:n,ref:c,specifier:p}}var S={name:"http",matches:r=>{try{return new URL(r),!0}catch{return  false}},parse:(r,e)=>{let t=N(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{url:e}=N(r,{fullyQualified:false});return new URL(e).origin},state:async r=>{let{url:e}=N(r,{fullyQualified:false});return {url:e,provider:S}},resolveRaw:async(r,e)=>{if(r.provider.name!==S.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${S.name} provider.`);return new URL(e,r.url)},authHeader:r=>["Authorization",`Bearer ${r}`],formatFetchError:(r,e,t)=>`There was an error fetching ${y.bold(new URL(e,r.url).toString())}
	
${y.bold(t)}`};function N(r,{fullyQualified:e}){let t=new URL(r),i=t.pathname.split("/"),a;return e&&(a=i.slice(i.length-2).join("/"),i=i.slice(0,i.length-2)),{url:C(f(t.origin,...i)),specifier:a}}var Re=/^(?![-0-9])(?!.*--)[a-z0-9]*(?:-[a-z0-9]+)*$/gi,W="https://www.jsrepo.com",R={name:"jsrepo",matches:r=>r.startsWith("@"),parse:(r,e)=>{let t=L(r,e);return {url:t.url,specifier:t.specifier}},baseUrl:r=>{let{scope:e,registryName:t,version:i}=L(r,{fullyQualified:false});return `${W}/${e}/${t}/v/${i}`},state:async r=>({...L(r,{fullyQualified:false}),provider:R}),resolveRaw:async(r,e)=>{if(r.provider.name!==R.name)throw new Error(`You passed the incorrect state object (${r.provider.name}) to the ${R.name} provider.`);let{scope:t,registryName:i,version:a}=r;return new URL(`${W}/api/scopes/${t}/${i}/v/${a}/files/${e}`)},authHeader:r=>["x-api-key",r],formatFetchError:(r,e,t)=>{let{scope:i,registryName:a,version:n}=r;return `There was an error fetching ${e} from ${i}/${a}@${n}
	
${y.bold(t)}`}};function L(r,{fullyQualified:e}){let[t,i,...a]=r.split("/"),[n,s]=i.split("@"),p;return e&&(p=a.slice(a.length-2).join("/")),{url:`${t}/${i}`,specifier:p,scope:t,registryName:n,version:s??"latest"}}var A=class{_result;constructor(e){this._result=e;}match(e,t){return this._result.ok?e(this._result.val):t(this._result.err)}map(e){return this.match(t=>g(e(t)),t=>u(t))}mapOr(e,t){return this.match(i=>t(i),i=>e)}mapOrElse(e,t){return this.match(i=>t(i),i=>e(i))}mapErr(e){return this.match(t=>g(t),t=>u(e(t)))}mapErrOr(e,t){return this.match(i=>e,i=>t(i))}mapErrOrElse(e,t){return this.match(i=>e(i),i=>t(i))}isOk(){return this.match(()=>true,()=>false)}isErr(){return this.match(()=>false,()=>true)}unwrap(){return this.match(e=>e,()=>{throw new Error("Attempted to call `.unwrap()` on a non `Ok` value.")})}unwrapErr(){return this.match(()=>{throw new Error("Attempted to call `.unwrapErr()` on a non `Err` value.")},e=>e)}unwrapOr(e){return this.match(t=>t,t=>e)}unwrapErrOr(e){return this.match(()=>e,t=>t)}unwrapOrElse(e){return this.match(t=>t,t=>e(t))}unwrapErrOrElse(e){return this.match(t=>e(t),t=>t)}expect(e){return this.match(t=>t,()=>{throw new Error(e)})}expectErr(e){return this.match(()=>{throw new Error(e)},t=>t)}};function g(r){return new A({ok:true,val:r})}function u(r){return new A({ok:false,err:r})}function Y(r){let e;try{e=JSON.parse(r);}catch(i){return u(`Error parsing manifest json ${i}`)}if(Array.isArray(e)){let i=o.safeParse(o.array(T),e);return i.success?g({private:false,categories:i.output}):u(`Error parsing categories (array-based config) ${i.issues.join(" ")}`)}let t=o.safeParse(F,e);return t.success?g(t.output):u(`Error parsing manifest ${t.issues.join(" ")}`)}function je(r,e,t){return {name:t.name,version:t.version,meta:t.meta,access:t.access,peerDependencies:t.peerDependencies,configFiles:e,categories:r}}var ie=[R,E,v,m,b,S];function Ie(r){return ie.find(t=>t.matches(r))}async function se(r,e,{verbose:t,fetch:i=fetch,token:a}={}){let n=await r.provider.resolveRaw(r,e);t?.(`Trying to fetch from ${n}`);try{let s={};if(a!==void 0&&r.provider.authHeader){let[c,l]=r.provider.authHeader(a);s[c]=l;}let p=await i(n.toString(),{headers:s});return t?.(`Got a response from ${n} ${p.status} ${p.statusText}`),p.ok?g(await p.text()):u(r.provider.formatFetchError(r,e,`${p.status} ${p.statusText}`))}catch(s){return u(r.provider.formatFetchError(r,e,s))}}async function Me(r,{fetch:e=fetch,...t}={}){let i=await se(r,_,{fetch:e,...t});return i.isErr()?u(i.unwrapErr()):Y(i.unwrap())}export{se as A,Me as B,g as a,u as b,f as c,Q as d,T as e,J as f,q as g,K as h,V as i,X as j,F as k,ue as l,_ as m,ae as n,Y as o,je as p,b as q,m as r,E as s,v as t,S as u,Re as v,W as w,R as x,ie as y,Ie as z};//# sourceMappingURL=chunk-GJE55QJV.js.map
//# sourceMappingURL=chunk-GJE55QJV.js.map